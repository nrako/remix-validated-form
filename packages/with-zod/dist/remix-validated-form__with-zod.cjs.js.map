{"version":3,"file":"remix-validated-form__with-zod.cjs.js","sources":["../../../node_modules/remeda/dist/es/purry.js","../../../node_modules/remeda/dist/es/equals.js","../../set-get/src/stringToPathArray.ts","../src/index.ts"],"sourcesContent":["var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\n/**\n * Creates a function with `data-first` and `data-last` signatures.\n *\n * `purry` is a dynamic function and it's not type safe. It should be wrapped by a function that have proper typings.\n * Refer to the example below for correct usage.\n *\n * @param fn the function to purry.\n * @param args the arguments\n * @signature R.purry(fn, arguments);\n * @example-raw\n *    function _findIndex(array, fn) {\n *      for (let i = 0; i < array.length; i++) {\n *        if (fn(array[i])) {\n *          return i;\n *        }\n *      }\n *      return -1;\n *    }\n *\n *    // data-first\n *    function findIndex<T>(array: T[], fn: (item: T) => boolean): number;\n *\n *    // data-last\n *    function findIndex<T>(fn: (item: T) => boolean): (array: T[]) => number;\n *\n *    function findIndex() {\n *      return R.purry(_findIndex, arguments);\n *    }\n * @category Function\n */\nexport function purry(fn, args, lazy) {\n    var diff = fn.length - args.length;\n    var arrayArgs = Array.from(args);\n    if (diff === 0) {\n        return fn.apply(void 0, arrayArgs);\n    }\n    if (diff === 1) {\n        var ret = function (data) { return fn.apply(void 0, __spreadArray([data], arrayArgs, false)); };\n        if (lazy || fn.lazy) {\n            ret.lazy = lazy || fn.lazy;\n            ret.lazyArgs = args;\n        }\n        return ret;\n    }\n    throw new Error('Wrong number of arguments');\n}\n","import { purry } from './purry';\n// from https://github.com/epoberezkin/fast-deep-equal/blob/master/index.js\nvar isArray = Array.isArray;\nvar keyList = Object.keys;\nvar hasProp = Object.prototype.hasOwnProperty;\nexport function equals() {\n    return purry(_equals, arguments);\n}\nfunction _equals(a, b) {\n    if (a === b) {\n        return true;\n    }\n    if (a && b && typeof a === 'object' && typeof b === 'object') {\n        var arrA = isArray(a);\n        var arrB = isArray(b);\n        var i = void 0;\n        var length = void 0;\n        var key = void 0;\n        if (arrA && arrB) {\n            length = a.length;\n            if (length !== b.length) {\n                return false;\n            }\n            for (i = length; i-- !== 0;) {\n                if (!equals(a[i], b[i])) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        if (arrA !== arrB) {\n            return false;\n        }\n        var dateA = a instanceof Date;\n        var dateB = b instanceof Date;\n        if (dateA !== dateB) {\n            return false;\n        }\n        if (dateA && dateB) {\n            return a.getTime() === b.getTime();\n        }\n        var regexpA = a instanceof RegExp;\n        var regexpB = b instanceof RegExp;\n        if (regexpA !== regexpB) {\n            return false;\n        }\n        if (regexpA && regexpB) {\n            return a.toString() === b.toString();\n        }\n        var keys = keyList(a);\n        length = keys.length;\n        if (length !== keyList(b).length) {\n            return false;\n        }\n        for (i = length; i-- !== 0;) {\n            if (!hasProp.call(b, keys[i])) {\n                return false;\n            }\n        }\n        for (i = length; i-- !== 0;) {\n            key = keys[i];\n            if (!equals(a[key], b[key])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    return a !== a && b !== b;\n}\n","export const stringToPathArray = <T extends string>(\n  path: T\n): (string | number)[] => {\n  if (path.length === 0) return [];\n\n  const match =\n    path.match(/^\\[(.+?)\\](.*)$/) || path.match(/^\\.?([^\\.\\[\\]]+)(.*)$/);\n  if (match) {\n    const [_, key, rest] = match;\n    return [/^\\d+$/.test(key) ? Number(key) : key, ...stringToPathArray(rest)];\n  }\n  return [path];\n};\n","import * as R from \"remeda\";\nimport { createValidator, FieldErrors, Validator } from \"remix-validated-form\";\nimport { stringToPathArray } from \"set-get\";\nimport type { z } from \"zod\";\n\nconst getIssuesForError = (err: z.ZodError<any>): z.ZodIssue[] => {\n  return err.issues.flatMap((issue) => {\n    if (\"unionErrors\" in issue) {\n      return issue.unionErrors.flatMap((err) => getIssuesForError(err));\n    } else {\n      return [issue];\n    }\n  });\n};\n\nfunction pathToString(array: (string | number)[]): string {\n  return array.reduce(function (string: string, item: string | number) {\n    const prefix = string === \"\" ? \"\" : \".\";\n    return string + (isNaN(Number(item)) ? prefix + item : \"[\" + item + \"]\");\n  }, \"\");\n}\n\n/**\n * Create a validator using a `zod` schema.\n */\nexport function withZod<T, U extends z.ZodTypeDef>(\n  zodSchema: z.Schema<T, U, unknown>,\n  parseParams?: Partial<z.ParseParams>\n): Validator<T> {\n  return createValidator({\n    validate: async (value) => {\n      const result = await zodSchema.safeParseAsync(value, parseParams);\n      if (result.success) return { data: result.data, error: undefined };\n\n      const fieldErrors: FieldErrors = {};\n      getIssuesForError(result.error).forEach((issue) => {\n        const path = pathToString(issue.path);\n        if (!fieldErrors[path]) fieldErrors[path] = issue.message;\n      });\n      return { error: fieldErrors, data: undefined };\n    },\n    validateField: async (data, field) => {\n      const result = await zodSchema.safeParseAsync(data, parseParams);\n      if (result.success) return { error: undefined };\n      return {\n        error: getIssuesForError(result.error).find((issue) =>\n          R.equals(issue.path, stringToPathArray(field))\n        )?.message,\n      };\n    },\n  });\n}\n"],"names":["__spreadArray","this","to","from","pack","i","l","ar","purry","fn","args","lazy","diff","arrayArgs","ret","data","isArray","keyList","hasProp","equals","_equals","a","b","arrA","arrB","length","key","dateA","dateB","regexpA","regexpB","keys","stringToPathArray","path","match","_","rest","getIssuesForError","err","issue","pathToString","array","string","item","prefix","withZod","zodSchema","parseParams","createValidator","value","result","fieldErrors","field","_a","R.equals"],"mappings":"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"}