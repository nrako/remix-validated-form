{"version":3,"file":"remix-validated-form__with-zod.es.js","sources":["../../../node_modules/remeda/dist/es/purry.js","../../../node_modules/remeda/dist/es/equals.js","../../set-get/src/stringToPathArray.ts","../src/index.ts"],"sourcesContent":["var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\n/**\n * Creates a function with `data-first` and `data-last` signatures.\n *\n * `purry` is a dynamic function and it's not type safe. It should be wrapped by a function that have proper typings.\n * Refer to the example below for correct usage.\n *\n * @param fn the function to purry.\n * @param args the arguments\n * @signature R.purry(fn, arguments);\n * @example-raw\n *    function _findIndex(array, fn) {\n *      for (let i = 0; i < array.length; i++) {\n *        if (fn(array[i])) {\n *          return i;\n *        }\n *      }\n *      return -1;\n *    }\n *\n *    // data-first\n *    function findIndex<T>(array: T[], fn: (item: T) => boolean): number;\n *\n *    // data-last\n *    function findIndex<T>(fn: (item: T) => boolean): (array: T[]) => number;\n *\n *    function findIndex() {\n *      return R.purry(_findIndex, arguments);\n *    }\n * @category Function\n */\nexport function purry(fn, args, lazy) {\n    var diff = fn.length - args.length;\n    var arrayArgs = Array.from(args);\n    if (diff === 0) {\n        return fn.apply(void 0, arrayArgs);\n    }\n    if (diff === 1) {\n        var ret = function (data) { return fn.apply(void 0, __spreadArray([data], arrayArgs, false)); };\n        if (lazy || fn.lazy) {\n            ret.lazy = lazy || fn.lazy;\n            ret.lazyArgs = args;\n        }\n        return ret;\n    }\n    throw new Error('Wrong number of arguments');\n}\n","import { purry } from './purry';\n// from https://github.com/epoberezkin/fast-deep-equal/blob/master/index.js\nvar isArray = Array.isArray;\nvar keyList = Object.keys;\nvar hasProp = Object.prototype.hasOwnProperty;\nexport function equals() {\n    return purry(_equals, arguments);\n}\nfunction _equals(a, b) {\n    if (a === b) {\n        return true;\n    }\n    if (a && b && typeof a === 'object' && typeof b === 'object') {\n        var arrA = isArray(a);\n        var arrB = isArray(b);\n        var i = void 0;\n        var length = void 0;\n        var key = void 0;\n        if (arrA && arrB) {\n            length = a.length;\n            if (length !== b.length) {\n                return false;\n            }\n            for (i = length; i-- !== 0;) {\n                if (!equals(a[i], b[i])) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        if (arrA !== arrB) {\n            return false;\n        }\n        var dateA = a instanceof Date;\n        var dateB = b instanceof Date;\n        if (dateA !== dateB) {\n            return false;\n        }\n        if (dateA && dateB) {\n            return a.getTime() === b.getTime();\n        }\n        var regexpA = a instanceof RegExp;\n        var regexpB = b instanceof RegExp;\n        if (regexpA !== regexpB) {\n            return false;\n        }\n        if (regexpA && regexpB) {\n            return a.toString() === b.toString();\n        }\n        var keys = keyList(a);\n        length = keys.length;\n        if (length !== keyList(b).length) {\n            return false;\n        }\n        for (i = length; i-- !== 0;) {\n            if (!hasProp.call(b, keys[i])) {\n                return false;\n            }\n        }\n        for (i = length; i-- !== 0;) {\n            key = keys[i];\n            if (!equals(a[key], b[key])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    return a !== a && b !== b;\n}\n","export const stringToPathArray = <T extends string>(\n  path: T\n): (string | number)[] => {\n  if (path.length === 0) return [];\n\n  const match =\n    path.match(/^\\[(.+?)\\](.*)$/) || path.match(/^\\.?([^\\.\\[\\]]+)(.*)$/);\n  if (match) {\n    const [_, key, rest] = match;\n    return [/^\\d+$/.test(key) ? Number(key) : key, ...stringToPathArray(rest)];\n  }\n  return [path];\n};\n","import * as R from \"remeda\";\nimport { createValidator, FieldErrors, Validator } from \"remix-validated-form\";\nimport { stringToPathArray } from \"set-get\";\nimport type { z } from \"zod\";\n\nconst getIssuesForError = (err: z.ZodError<any>): z.ZodIssue[] => {\n  return err.issues.flatMap((issue) => {\n    if (\"unionErrors\" in issue) {\n      return issue.unionErrors.flatMap((err) => getIssuesForError(err));\n    } else {\n      return [issue];\n    }\n  });\n};\n\nfunction pathToString(array: (string | number)[]): string {\n  return array.reduce(function (string: string, item: string | number) {\n    const prefix = string === \"\" ? \"\" : \".\";\n    return string + (isNaN(Number(item)) ? prefix + item : \"[\" + item + \"]\");\n  }, \"\");\n}\n\n/**\n * Create a validator using a `zod` schema.\n */\nexport function withZod<T, U extends z.ZodTypeDef>(\n  zodSchema: z.Schema<T, U, unknown>,\n  parseParams?: Partial<z.ParseParams>\n): Validator<T> {\n  return createValidator({\n    validate: async (value) => {\n      const result = await zodSchema.safeParseAsync(value, parseParams);\n      if (result.success) return { data: result.data, error: undefined };\n\n      const fieldErrors: FieldErrors = {};\n      getIssuesForError(result.error).forEach((issue) => {\n        const path = pathToString(issue.path);\n        if (!fieldErrors[path]) fieldErrors[path] = issue.message;\n      });\n      return { error: fieldErrors, data: undefined };\n    },\n    validateField: async (data, field) => {\n      const result = await zodSchema.safeParseAsync(data, parseParams);\n      if (result.success) return { error: undefined };\n      return {\n        error: getIssuesForError(result.error).find((issue) =>\n          R.equals(issue.path, stringToPathArray(field))\n        )?.message,\n      };\n    },\n  });\n}\n"],"names":["this","err","R.equals"],"mappings":"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"}