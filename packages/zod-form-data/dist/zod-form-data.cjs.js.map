{"version":3,"file":"zod-form-data.cjs.js","sources":["../../set-get/src/stringToPathArray.ts","../../set-get/src/setPath.ts","../src/helpers.ts"],"sourcesContent":["export const stringToPathArray = <T extends string>(\n  path: T\n): (string | number)[] => {\n  if (path.length === 0) return [];\n\n  const match =\n    path.match(/^\\[(.+?)\\](.*)$/) || path.match(/^\\.?([^\\.\\[\\]]+)(.*)$/);\n  if (match) {\n    const [_, key, rest] = match;\n    return [/^\\d+$/.test(key) ? Number(key) : key, ...stringToPathArray(rest)];\n  }\n  return [path];\n};\n","import { stringToPathArray } from \"./stringToPathArray\";\n\nexport function setPath<T>(object: T, path: string, defaultValue: any) {\n  return _setPathNormalized(object, stringToPathArray(path), defaultValue);\n}\n\nfunction _setPathNormalized(\n  object: any,\n  path: (string | number)[],\n  value: any\n): any {\n  const leadingSegments = path.slice(0, -1);\n  const lastSegment = path[path.length - 1];\n\n  let obj = object;\n  for (let i = 0; i < leadingSegments.length; i++) {\n    const segment = leadingSegments[i];\n    if (obj[segment] === undefined) {\n      const nextSegment = leadingSegments[i + 1] ?? lastSegment;\n      obj[segment] = typeof nextSegment === \"number\" ? [] : {};\n    }\n    obj = obj[segment];\n  }\n  obj[lastSegment] = value;\n  return object;\n}\n","import { setPath } from \"set-get\";\nimport {\n  z,\n  ZodArray,\n  ZodEffects,\n  ZodNumber,\n  ZodObject,\n  ZodString,\n  ZodType,\n  ZodTypeAny,\n} from \"zod\";\n\ntype InputType<DefaultType extends ZodTypeAny> = {\n  (): ZodEffects<DefaultType>;\n  <ProvidedType extends ZodTypeAny>(\n    schema: ProvidedType\n  ): ZodEffects<ProvidedType>;\n};\n\nconst stripEmpty = z.literal(\"\").transform(() => undefined);\n\nconst preprocessIfValid = (schema: ZodTypeAny) => (val: unknown) => {\n  const result = schema.safeParse(val);\n  if (result.success) return result.data;\n  return val;\n};\n\n/**\n * Transforms any empty strings to `undefined` before validating.\n * This makes it so empty strings will fail required checks,\n * allowing you to use `optional` for optional fields instead of `nonempty` for required fields.\n * If you call `zfd.text` with no arguments, it will assume the field is a required string by default.\n * If you want to customize the schema, you can pass that as an argument.\n */\nexport const text: InputType<ZodString> = (schema = z.string()) =>\n  z.preprocess(preprocessIfValid(stripEmpty), schema);\n\n/**\n * Coerces numerical strings to numbers transforms empty strings to `undefined` before validating.\n * If you call `zfd.number` with no arguments,\n * it will assume the field is a required number by default.\n * If you want to customize the schema, you can pass that as an argument.\n */\nexport const numeric: InputType<ZodNumber> = (schema = z.number()) =>\n  z.preprocess(\n    preprocessIfValid(\n      z.union([\n        stripEmpty,\n        z\n          .string()\n          .transform((val) => Number(val))\n          .refine((val) => !Number.isNaN(val)),\n      ])\n    ),\n    schema\n  );\n\ntype CheckboxOpts = {\n  trueValue?: string;\n};\n\n/**\n * Turns the value from a checkbox field into a boolean,\n * but does not require the checkbox to be checked.\n * For checkboxes with a `value` attribute, you can pass that as the `trueValue` option.\n *\n * @example\n * ```ts\n * const schema = zfd.formData({\n *   defaultCheckbox: zfd.checkbox(),\n *   checkboxWithValue: zfd.checkbox({ trueValue: \"true\" }),\n *   mustBeTrue: zfd\n *     .checkbox()\n *     .refine((val) => val, \"Please check this box\"),\n *   });\n * });\n * ```\n */\nexport const checkbox = ({ trueValue = \"on\" }: CheckboxOpts = {}) =>\n  z.union([\n    z.literal(trueValue).transform(() => true),\n    z.literal(undefined).transform(() => false),\n  ]);\n\nexport const file: InputType<z.ZodType<File>> = (schema = z.instanceof(File)) =>\n  z.preprocess((val) => {\n    //Empty File object on no user input, so convert to undefined\n    return val instanceof File && val.size === 0 ? undefined : val;\n  }, schema);\n\n/**\n * Preprocesses a field where you expect multiple values could be present for the same field name\n * and transforms the value of that field to always be an array.\n * If you don't provide a schema, it will assume the field is an array of zfd.text fields\n * and will not require any values to be present.\n */\nexport const repeatable: InputType<ZodArray<any>> = (\n  schema = z.array(text())\n) => {\n  return z.preprocess((val) => {\n    if (Array.isArray(val)) return val;\n    if (val === undefined) return [];\n    return [val];\n  }, schema);\n};\n\n/**\n * A convenience wrapper for repeatable.\n * Instead of passing the schema for an entire array, you pass in the schema for the item type.\n */\nexport const repeatableOfType = <T extends ZodTypeAny>(\n  schema: T\n): ZodEffects<ZodArray<T>> => repeatable(z.array(schema));\n\nconst entries = z.array(z.tuple([z.string(), z.any()]));\n\ntype FormDataType = {\n  <T extends z.ZodRawShape>(shape: T): ZodEffects<ZodObject<T>>;\n  <T extends z.ZodTypeAny>(schema: T): ZodEffects<T>;\n};\n\nconst safeParseJson = (jsonString: string) => {\n  try {\n    return JSON.parse(jsonString);\n  } catch {\n    return jsonString;\n  }\n};\n\nexport const json = <T extends ZodTypeAny>(schema: T): ZodEffects<T> =>\n  z.preprocess(\n    preprocessIfValid(\n      z.union([stripEmpty, z.string().transform((val) => safeParseJson(val))])\n    ),\n    schema\n  );\n\nconst processFormData = preprocessIfValid(\n  // We're avoiding using `instanceof` here because different environments\n  // won't necessarily have `FormData` or `URLSearchParams`\n  z\n    .any()\n    .refine((val) => Symbol.iterator in val)\n    .transform((val) => [...val])\n    .refine(\n      (val): val is z.infer<typeof entries> => entries.safeParse(val).success\n    )\n    .transform((data): Record<string, unknown | unknown[]> => {\n      const map: Map<string, unknown[]> = new Map();\n      for (const [key, value] of data) {\n        if (map.has(key)) {\n          map.get(key)!.push(value);\n        } else {\n          map.set(key, [value]);\n        }\n      }\n\n      return [...map.entries()].reduce((acc, [key, value]) => {\n        return setPath(acc, key, value.length === 1 ? value[0] : value);\n      }, {} as Record<string, unknown | unknown[]>);\n    })\n);\n\nexport const preprocessFormData = processFormData as (\n  formData: unknown\n) => Record<string, unknown>;\n\n/**\n * This helper takes the place of the `z.object` at the root of your schema.\n * It wraps your schema in a `z.preprocess` that extracts all the data out of a `FormData`\n * and transforms it into a regular object.\n * If the `FormData` contains multiple entries with the same field name,\n * it will automatically turn that field into an array.\n */\nexport const formData: FormDataType = <T extends z.ZodRawShape | z.ZodTypeAny>(\n  shapeOrSchema: T\n) =>\n  z.preprocess(\n    processFormData,\n    shapeOrSchema instanceof ZodType ? shapeOrSchema : z.object(shapeOrSchema)\n  );\n"],"names":["stringToPathArray","path","match","_","key","rest","setPath","object","defaultValue","_setPathNormalized","value","leadingSegments","lastSegment","obj","i","segment","nextSegment","_a","stripEmpty","z","preprocessIfValid","schema","val","result","text","numeric","checkbox","trueValue","file","repeatable","repeatableOfType","entries","safeParseJson","jsonString","json","processFormData","data","map","acc","preprocessFormData","formData","shapeOrSchema","ZodType"],"mappings":"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"}